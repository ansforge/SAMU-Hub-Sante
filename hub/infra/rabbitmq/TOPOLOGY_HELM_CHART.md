# Custom Helm Chart to generate Topology Objects

This Helm chart's purpose is to generate all the topology objects monitored by the Message Topology Operator, by using templates.

For this reason, it **must** be called **after** the Message Topology Operator has been installed, and all the required CRDs have been created.
We can easily check this by running:

```bash
kubectl get crds -n rabbitmq-system
```

It should contain CRDs with *rabbitmq.com* suffix.

When running  
```bash
helm upgrade -i hubsante-topology ./hubsante-topology
```
helm will eventually generate a single manifest, concatenating all the templates, and apply it to the cluster.

For readability, we chose to split the templates in multiple files, but this is not mandatory. So we have templates to define:
- the admin user (for management console access)
- all the objects relative to the dispatcher, including common objects like exchanges, etc
- all the policies applied to the cluster (only dead-lettering for know, should contain eventually also federation configuration)
- all the objects relative to the clients; for readability we split them in several files

The objects generated by this chart can lay in another namespace than the operator; we think it's convenient to have them separately from the operator resources,
in order to clearly distinguish CRDs and monitoring objects from the "business" objects. So the operator resources lay in the 'rabbitmq-system' namespace (by default),
while the "business" objects lay in the 'rabbitmq' namespace.

For each of these objects, we specify a RabbitmqClusterReference, which points to the cluster instance we want the operator to interact with.
By default, the topology objects must lay in the same namespace as the cluster instance, but we can override this behavior by adding an annotation in the RabbitmqCluster manifest
(so not in this helm chart perimeter): "rabbitmq.com/topology-allowed-namespaces".

We chose to put the RabbitmqCluster in the 'rabbitmq' namespace too, but added this annotation and comment it in the RabbitmqCluster manifest for further reference.

After applying the topology objects, we can check that they have been created by running:
```bash
kubectl get all -n rabbitmq
```
We can inspect them by running:
```bash
kubectl describe queue.rabbitmq.com/dispatch-queue -n rabbitmq
```
or in the Kubernetes dashboard.

As soon as an object is created, it is monitored by the operator. All changes will end by a reconciliation handled by a webhook, which will update the object in RabbitMQ through the API.
We can look at it in the services list of the rabbitmq-system namespace.
All the webhooks (one for each CRD !) need TLS.

For now, we've put generic values in the values.yaml file.
Next, we could generate multiple values.yaml files, like a sandbox.values.yaml (editor users + clientA, B, Z for the LRM interface), a staging.values.yaml, a production.values.yaml, etc.

values.yaml also contains a 'clusterNamespace' field, which should allow us to deploy a rabbitmq-sandbox and a rabbitmq-staging cluster in the same environment (it could be a good reason to look
on how to deploy the Rabbitmq Cluster Operator with helm too, for the same purpose)


### IMPORTANT NOTE
By default, the operator automatically and randomly generates credentials for newly created users, unless we reference an existing secret.
The credentials are read-only, so can not be updated since the user has been created. So we need to create a secret first with no password
(in the same namespace as the object).