# v0.4: Transcodage

## Changements
- L'exchange `hubsante` est désormais `durable`. Les `Consumer`et `Producer` doivent donc modifier leur déclaration pour prendre ce paramètre en compte.
- `Consumer` et `Producer` sont désormais des classes indépendantes et sans `main`pour pouvoir être intégrées plus facilement à des codes les appelant différemment.
- `ConsumerRun` et `ProducerRun` permettent de faire les appels aux nouvelles classes `Consumer` et `Producer` 

## Documentation
- Le DST v0.2 contient des informations détaillées
- La documentation d'AsyncAPI
  - Les [concepts](https://www.asyncapi.com/docs/concepts)
  - Les [tutoriels](https://www.asyncapi.com/docs/tutorials)
  - Les [spécifications](https://www.asyncapi.com/docs/reference/specification/v2.5.0)

## Objectifs
- [ ] Lire et utiliser un fichier de spécifications AsyncAPI
- [ ] Intégrer les classes correspondantes dans les `Producer` et `Consumer`

## Messages
Le format des messages de la v0.4 est défini dans le fichier de spécifications AsyncAPI suivant : [`dispatcher/src/main/resources/hubsante.asyncapi.yaml`](../dispatcher/src/main/resources/hubsante.asyncapi.yaml)

## Implémentation Java
<<<<<<< HEAD
- [x] Voir la section [`Scripts utiles > Certificats`](#certificats)
  - CSR [`certs/client.csr`](../certs/client.csr) signée par la CA du Hub en [`certs/client.crt`](../certs/client.crt)
  - Transformé en [`certs/client.p12`](../certs/client.p12) utilisé par le `KeyManager`
  - Ajout du certificat du hub au `trustStore` du client ([détails](../certs/addToKeystore.md))
- [x] Logique de la connexion TLS ajoutée dans [`Utils.TLS.enableTLS`](../client/src/main/java/com/hubsante/Utils.java)
- [x] Evolution des [`Consumer.java`](../client/src/main/java/com/hubsante/Consumer.java) et [`Producer.java`](../client/src/main/java/com/hubsante/Producer.java) pour se connecter en TLS
=======
- [x] Le dossier [`models/`](../models) exploite le fichier de spécifications AsyncAPI pour générer les classes correspondantes
- [x] Les classes sont ensuite intégrés dans [`com.hubsante.message`](../src/main/java/com/hubsante/message) et peuvent être utilisées facilement par les autres fichiers
>>>>>>> main

## Test
```
# Shell 1: run Hub Santé locally
docker compose up

# Shell 2: run *.in.message Target-Sante Consumer
CLIENT_ID=Target-Sante; gradle -Pmain=com.hubsante.ConsumerRun run --args "$CLIENT_ID.in.message"

# Shell 3: run *.in.ack Self-Sante Consumer
CLIENT_ID=Self-Sante; gradle -Pmain=com.hubsante.ConsumerRun run --args "$CLIENT_ID.in.ack"

# Shell 4: run Self-Sante Producer each time you want to send a message
CLIENT_ID=Self-Sante; gradle -Pmain=com.hubsante.ProducerRun run --args "$CLIENT_ID.out.message src/main/resources/simpleMessage.json"
```
Test : confirm messages are 
- read by message Target-Sante Consumer
- sends Ack back to Hub
- read by Self-Sante ack Consumer 
- all correctly technically ack-ed (check through [RabbitMQ UI](http://localhost:15672)) 

## Scripts utiles
### Docker (RabbitMQ & Hub)
```bash
## Reconstruire les images du Hub
gradle jibDockerBuild --image=hub-sante:hub

## Lancer le Hub
docker compose up

## Reconstruire et lancer le Hub
gradle jibDockerBuild --image=hub-sante:hub && docker compose up

## SSH dans le noeud RabbitMQ
docker compose exec rabbitmq sh 
```
L'interface [admin de RabbitMQ](http://localhost:15672) est accessible avec le compte guest:guest.

### Consumer / Producer
##### Linux / MAC OS
```bash
## Lancer un Consumer sur $CLIENT_ID.in.message
CLIENT_ID=Self-Sante; gradle -Pmain=com.hubsante.ConsumerRun run --args "$CLIENT_ID.in.message"

## Lancer un Consumer sur $CLIENT_ID.in.ack
CLIENT_ID=Self-Sante; gradle -Pmain=com.hubsante.ConsumerRun run --args "$CLIENT_ID.in.ack"

## Envoyer un message sur $CLIENT_ID.out.message avec un Producer
CLIENT_ID=Self-Sante; gradle -Pmain=com.hubsante.ProducerRun run --args "$CLIENT_ID.out.message src/main/resources/simpleMessage.json"
```

##### Windows
```bash
## set variable
set CLIENT_ID=Self-Sante
## Lancer un Consumer sur $CLIENT_ID.in.message
gradle -Pmain=com.hubsante.Consumer run --args "%CLIENT_ID%.in.message"

## Lancer un Consumer sur $CLIENT_ID.in.ack
gradle -Pmain=com.hubsante.Consumer run --args "%CLIENT_ID%.in.ack"

## Envoyer un message sur $CLIENT_ID.out.message avec un Producer
gradle -Pmain=com.hubsante.Producer run --args "%CLIENT_ID%.out.message {'to': '%CLIENT_ID%', 'senderId': '%CLIENT_ID%', 'distributionId': '%CLIENT_ID%_messageId123', 'content': 'test'}"
```

### Certificats
```bash
## Générer votre CSR (en remplaçant la valeur client de $DOMAIN par votre identifiant client) 
cd certs
DOMAIN=client ./generate.sh
## Après transmission de votre CSR à l'équipe Hub Santé, vous recevrez un certificat signé par l'AC (en .crt)

## Conversion en .p12
export DOMAIN=client; openssl pkcs12 -inkey "$DOMAIN".key -in "$DOMAIN".crt -export -out "$DOMAIN".p12

## Ajouter le Hub au trustStore utilisé par le client
keytool -import -alias RabbitMQHubSante -file rabbitmq/certs/hub.crt -keystore certs/trustStore

## Voir les détails d'un certificat
export DOMAIN=client; openssl x509 -text -noout -in "$DOMAIN".crt

## Vérifier qu'un certificat est bien signé par la CA
openssl verify -CAfile certs/CA/rootCA.crt certs/client.crt
```

### TLS
Ref.: https://www.rabbitmq.com/troubleshooting-ssl.html
```bash
## Créer un serveur TLS avec les certificats du Hub
openssl s_server -accept 8443 -cert rabbitmq/certs/hub.crt -key rabbitmq/certs/hub.key -CAfile rabbitmq/certs/rootCA.crt

## Créer un client se connectant en TLS avec les certificats clients au serveur TLS
openssl s_client -connect localhost:8443 \
  -cert certs/client.crt -key certs/client.key -CAfile certs/CA/rootCA.crt \
  -verify 8

## Créer un client se connectant en TLS avec les certificats clients au RabbitMQ
### Va donner un `handshake_timeout`dans les logs RabbitMQ car aucune donnée n'est transmise
### Mais une ligne similaire devrait apparaitre : [info] <0.769.0> accepting AMQP connection <0.769.0>
openssl s_client -connect localhost:5671 -cert certs/client.crt -key certs/client.key -CAfile certs/CA/rootCA.crt

## Créer un client se connectant en TLS1.1 avec les certificats clients au RabbitMQ -> retourne une `alert protocol version`
openssl s_client -connect localhost:5671 -cert certs/client.crt -key certs/client.key -CAfile certs/CA/rootCA.crt -tls1.1 

## Après SSH dans le noeud RabbitMQ (voir section Scripts utiles > Docker), voir les `listeners` actifs
rabbitmq-diagnostics status # Section Listeners doit avoir une ligne sur le port 5671
```

### Génération des classes basées sur les spécifications AsyncAPI
Plus de détails sont disponibles directement dans [`models/`](../models/README.md)
```bash
## Générer les classes
cd models; npm run generate

## Afficher localement la documentation sur http://localhost:8000
cd docs/specs; python -m http.server 
```
