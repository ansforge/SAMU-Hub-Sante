# v0.4: Transcodage

## Changements
- L'exchange `hubsante` est désormais `durable`. Les `Consumer`et `Producer` doivent donc modifier leur déclaration pour prendre ce paramètre en compte.

## Documentation
- Le DST v0.1.1 contient des informations plus détaillées sur les versions et messages
- Un [guide](https://www.baeldung.com/openssl-self-signed-cert) clair sur les certificats et `openssl`
- La documentation de RabbitMQ sur TLS
  - [Globalement](https://www.rabbitmq.com/ssl.html)
  - Sur les clients [Java](https://www.rabbitmq.com/ssl.html#java-client) et [.NET](https://www.rabbitmq.com/ssl.html#dotnet-client)
  - Pour [débugger](https://www.rabbitmq.com/troubleshooting-ssl.html) les connexions TLS 

## Objectifs
- [ ] Générer un certificat client signé par l'AC du Hub
- [ ] Implémenter la logique de connexion TLS
  - Certificat client dans un `KeyManager` pour l'envoyer avec la requête
  - Certificat du Hub dans un `TrustManager` pour valider l'identité du Hub
  - Connexion en TLS v1.2 minimum sur le port 5671
- [ ] Faire évoluer le `Consumer` et le `Producer` pour se connecter en TLS

## Messages
Le format des messages de la v0.4 est ...

## Implémentation Java
- [x] Voir la section [`Scripts utiles > Certificats`](#certificats)
  - CSR [`certs/client.csr`](../certs/client.csr) signée par la CA du Hub en [`certs/client.crt`](../certs/client.crt)
  - Transformé en [`certs/client.p12`](../certs/client.p12) utilisé par le `KeyManager`
  - Ajout du certificat du hub au `trustStore` du client ([détails](../certs/addToKeystore.md))
- [x] Logique de la connexion TLS ajoutée dans [`Utils.TLS.enableTLS`](../client/src/main/java/com/hubsante/Utils.java)
- [x] Evolution des [`Consumer.java`](../client/src/main/java/com/hubsante/Consumer.java) et [`Producer.java`](../client/src/main/java/com/hubsante/Producer.java) pour se connecter en TLS

## Test
Reproduire les tests de la [v0.2](v0.2.md).

## Scripts utiles
### Docker
```bash
## Reconstruire les images du Hub
gradle jibDockerBuild --image=hub-sante:hub

## Lancer le Hub
docker compose up

## Reconstruire et lancer le Hub
gradle jibDockerBuild --image=hub-sante:hub && docker compose up

## SSH dans le noeud RabbitMQ
docker compose exec rabbitmq sh 
```

### Consumer / Producer
##### Linux / MAC OS
```bash
## Lancer un Consumer sur $CLIENT_ID.in.message
CLIENT_ID=Self-Sante; gradle -Pmain=com.hubsante.Consumer run --args "$CLIENT_ID.in.message"

## Lancer un Consumer sur $CLIENT_ID.in.ack
CLIENT_ID=Self-Sante; gradle -Pmain=com.hubsante.Consumer run --args "$CLIENT_ID.in.ack"

## Envoyer un message sur $CLIENT_ID.out.message avec un Producer
CLIENT_ID=Self-Sante; gradle -Pmain=com.hubsante.Producer run --args "$CLIENT_ID.out.message {'to': '$CLIENT_ID', 'senderId': '$CLIENT_ID', 'distributionId': '${CLIENT_ID}_messageId123', 'content': 'test'}"
```

##### Windows
```bash
## set variable
set CLIENT_ID=Self-Sante
## Lancer un Consumer sur $CLIENT_ID.in.message
gradle -Pmain=com.hubsante.Consumer run --args "%CLIENT_ID%.in.message"

## Lancer un Consumer sur $CLIENT_ID.in.ack
gradle -Pmain=com.hubsante.Consumer run --args "%CLIENT_ID%.in.ack"

## Envoyer un message sur $CLIENT_ID.out.message avec un Producer
gradle -Pmain=com.hubsante.Producer run --args "%CLIENT_ID%.out.message {'to': '%CLIENT_ID%', 'senderId': '%CLIENT_ID%', 'distributionId': '%CLIENT_ID%_messageId123', 'content': 'test'}"
```

### Certificats
```bash
## Générer votre CSR (en remplaçant la valeur client de $DOMAIN par votre identifiant client) 
cd certs
DOMAIN=client ./generate.sh
## Après transmission de votre CSR à l'équipe Hub Santé, vous recevrez un certificat signé par l'AC (en .crt)

## Conversion en .p12
export DOMAIN=client; openssl pkcs12 -inkey "$DOMAIN".key -in "$DOMAIN".crt -export -out "$DOMAIN".p12

## Ajouter le Hub au trustStore utilisé par le client
keytool -import -alias RabbitMQHubSante -file rabbitmq/certs/hub.crt -keystore certs/trustStore

## Voir les détails d'un certificat
export DOMAIN=client; openssl x509 -text -noout -in "$DOMAIN".crt

## Vérifier qu'un certificat est bien signé par la CA
openssl verify -CAfile certs/CA/rootCA.crt certs/client.crt
```

### TLS
Ref.: https://www.rabbitmq.com/troubleshooting-ssl.html
```bash
## Créer un serveur TLS avec les certificats du Hub
openssl s_server -accept 8443 -cert rabbitmq/certs/hub.crt -key rabbitmq/certs/hub.key -CAfile rabbitmq/certs/rootCA.crt

## Créer un client se connectant en TLS avec les certificats clients au serveur TLS
openssl s_client -connect localhost:8443 \
  -cert certs/client.crt -key certs/client.key -CAfile certs/CA/rootCA.crt \
  -verify 8

## Créer un client se connectant en TLS avec les certificats clients au RabbitMQ
### Va donner un `handshake_timeout`dans les logs RabbitMQ car aucune donnée n'est transmise
### Mais une ligne similaire devrait apparaitre : [info] <0.769.0> accepting AMQP connection <0.769.0>
openssl s_client -connect localhost:5671 -cert certs/client.crt -key certs/client.key -CAfile certs/CA/rootCA.crt

## Créer un client se connectant en TLS1.1 avec les certificats clients au RabbitMQ -> retourne une `alert protocol version`
openssl s_client -connect localhost:5671 -cert certs/client.crt -key certs/client.key -CAfile certs/CA/rootCA.crt -tls1.1 

## Après SSH dans le noeud RabbitMQ (voir section Scripts utiles > Docker), voir les `listeners` actifs
rabbitmq-diagnostics status # Section Listeners doit avoir une ligne sur le port 5671
```
