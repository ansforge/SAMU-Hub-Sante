# v0.6: Transcodage et validation

## Changements
- Les clients RabbitMQ se connectent désormais au serveur en tant que users identifiés par le CN de leur certificat (authentification passwordless).
  Le mécanisme est implémenté côté serveur RabbitMQ (cf [rabbitmq.conf](../hub/rabbitmq/rabbitmq.conf) et [enabled.plugins](../hub/rabbitmq/enabled_plugins)) et côté client (cf commit```*3ffd9706*``` ).
- Implémentation de la logique de sérialisation / désérialisation JSON et XML côté serveur.


## Documentation
- Le DST v0.2 contient des informations détaillées
- La documentation d'AsyncAPI
    - Les [concepts](https://www.asyncapi.com/docs/concepts)
    - Les [tutoriels](https://www.asyncapi.com/docs/tutorials)
    - Les [spécifications](https://www.asyncapi.com/docs/reference/specification/v2.5.0)

## Objectifs
- [ ] Transcoder des messages entre JSON et XML
- [ ] Implémenter une mécanique de validation (contre Json-schema ou XSD)

## Messages
Le format des messages de la v0.6 est défini dans le fichier de spécifications AsyncAPI suivant : [`models/hubsante.asyncapi.yaml`](../models/hubsante.asyncapi.yaml)

## Implémentation Java
- [x] Ajout d'un service de sérialisation/ désérialisation de messages (uniquement CreateEventMessage à date) : [`JsonXmlConverter.java`](../hub/dispatcher/src/main/java/com/hubsante/hub/service/JsonXmlConverter.java). Il supporte également deux méthodes de validation (json schema & xsd).
- [x] Ajout d'un template handlebars pour la génération d'un message xml (uniquement CreateEventMessage à date) : [`cisu-create-message.handlebars`](../hub/dispatcher/src/main/resources/template/cisu-create-message.handlebars).
- [x] Ajout de la configuration du mapper Jackson dans le code exemple Java pour prendre en charge la bonne désérialisation des dates.

## Scripts utiles
### Docker (RabbitMQ & Hub)
```bash
## Reconstruire les images du Hub (se positionner dans le répertoire /hub)
gradle jibDockerBuild --image=hub-sante:hub

## Lancer le Hub
docker compose up

## Reconstruire et lancer le Hub
gradle jibDockerBuild --image=hub-sante:hub && docker compose up

## SSH dans le noeud RabbitMQ
docker compose exec rabbitmq sh 
```
L'interface [admin de RabbitMQ](http://localhost:15672) est accessible avec le compte guest:guest.

### Consumer / Producer
##### Linux / MAC OS
```bash
## Depuis le répertoire ./hub
# Shell 1
docker compose up

## Depuis le répertoire ./client :

## Lancer un Consumer sur $CLIENT_ID.in.message
# Shell 2
CLIENT_ID=Target; gradle -Pmain=com.hubsante.ConsumerRun run --args "$CLIENT_ID.in.message"

## Lancer un Consumer sur $CLIENT_ID.in.ack
#Shell 3
CLIENT_ID=Origin; gradle -Pmain=com.hubsante.ConsumerRun run --args "$CLIENT_ID.in.ack"

## Envoyer un message sur $CLIENT_ID.out.message avec un Producer
# Shell 4
CLIENT_ID=Origin; gradle -Pmain=com.hubsante.ProducerRun run --args "$CLIENT_ID.out.message src/main/resources/createEventMessage.json"
```

##### Windows
```bash
## Depuis le répertoire ./client

## Lancer un Consumer sur $CLIENT_ID.in.message
set CLIENT_ID=Target
gradle -Pmain=com.hubsante.Consumer run --args "%CLIENT_ID%.in.message"

## Lancer un Consumer sur $CLIENT_ID.in.ack
set CLIENT_ID=Origin
gradle -Pmain=com.hubsante.Consumer run --args "%CLIENT_ID%.in.ack"

## Envoyer un message sur $CLIENT_ID.out.message avec un Producer
set CLIENT_ID=Origin
gradle -Pmain=com.hubsante.ProducerRun run --args "$CLIENT_ID.out.message src/main/resources/createEventMessage.json"
```

### Certificats
```bash
## Générer votre CSR (en remplaçant la valeur client de $DOMAIN par votre identifiant client) 
cd certs
DOMAIN=client ./generate.sh
## Après transmission de votre CSR à l'équipe Hub Santé, vous recevrez un certificat signé par l'AC (en .crt)

## Conversion en .p12
export DOMAIN=client; openssl pkcs12 -inkey "$DOMAIN".key -in "$DOMAIN".crt -export -out "$DOMAIN".p12

## Ajouter le Hub au trustStore utilisé par le client
keytool -import -alias RabbitMQHubSante -file rabbitmq/certs/hub.crt -keystore certs/trustStore

## Voir les détails d'un certificat
export DOMAIN=client; openssl x509 -text -noout -in "$DOMAIN".crt

## Vérifier qu'un certificat est bien signé par la CA
openssl verify -CAfile certs/CA/rootCA.crt certs/client.crt
```

### TLS
Ref.: https://www.rabbitmq.com/troubleshooting-ssl.html
```bash
## Créer un serveur TLS avec les certificats du Hub
openssl s_server -accept 8443 -cert rabbitmq/certs/hub.crt -key rabbitmq/certs/hub.key -CAfile rabbitmq/certs/rootCA.crt

## Créer un client se connectant en TLS avec les certificats clients au serveur TLS
openssl s_client -connect localhost:8443 \
  -cert certs/client.crt -key certs/client.key -CAfile certs/CA/rootCA.crt \
  -verify 8

## Créer un client se connectant en TLS avec les certificats clients au RabbitMQ
### Va donner un `handshake_timeout`dans les logs RabbitMQ car aucune donnée n'est transmise
### Mais une ligne similaire devrait apparaitre : [info] <0.769.0> accepting AMQP connection <0.769.0>
openssl s_client -connect localhost:5671 -cert certs/client.crt -key certs/client.key -CAfile certs/CA/rootCA.crt

## Créer un client se connectant en TLS1.1 avec les certificats clients au RabbitMQ -> retourne une `alert protocol version`
openssl s_client -connect localhost:5671 -cert certs/client.crt -key certs/client.key -CAfile certs/CA/rootCA.crt -tls1.1 

## Après SSH dans le noeud RabbitMQ (voir section Scripts utiles > Docker), voir les `listeners` actifs
rabbitmq-diagnostics status # Section Listeners doit avoir une ligne sur le port 5671
```

### Génération des classes basées sur les spécifications AsyncAPI
Plus de détails sont disponibles directement dans [`models/`](../models/README.md)
```bash
## Générer les classes
cd models; npm run generate

## Afficher localement la documentation sur http://localhost:8000
cd docs/specs; python -m http.server 
```
