# v0.5: Transcodage

## Changements
- Une distinction a été opérée entre le code du hub lui-même, disponible dans `hub`, et le code exemple des `Consumer` et `Producer`, 
désormais disponibles dans `/client`.
- Chacun des deux sous-répertoires vient avec son propre fichier `build.gradle`, de façon à toujours pouvoir exécuter des tests localement.
- Le code serveur, sous `/hub`, s'appuie désormais sur le framework Spring. Cela permet une déclaration plus légère des Exchanges, 
des files et des Bindings, dans une unique classe de configuration `AmqpConfiguration`. 
La configuration SSL est entièrement déléguée à Spring et s'appuie sur des propriétés définies dans le fichier `application.properties`.

## Documentation
- Le DST v0.2 contient des informations détaillées
- La documentation d'AsyncAPI
    - Les [concepts](https://www.asyncapi.com/docs/concepts)
    - Les [tutoriels](https://www.asyncapi.com/docs/tutorials)
    - Les [spécifications](https://www.asyncapi.com/docs/reference/specification/v2.5.0)

## Objectifs
- [ ] Transposer le code du hub avec Spring
- [ ] Générer les classes du modèle à partir d'un fichier de spécifications AsyncAPI

## Messages
Le format des messages de la v0.5 est défini dans le fichier de spécifications AsyncAPI suivant : [`models/hubsante.asyncapi.yaml`](../models/hubsante.asyncapi.yaml)

## Implémentation Java
- [x] Voir la section [`Scripts utiles > Certificats`](#certificats)
    - CSR [`certs/client.csr`](../certs/client.csr) signée par la CA du Hub en [`certs/client.crt`](../certs/client.crt)
    - Transformé en [`certs/client.p12`](../certs/client.p12) utilisé par le `KeyManager`
    - Ajout du certificat du hub au `trustStore` du client ([détails](../certs/addToKeystore.md))
- [x] Logique de la connexion TLS ajoutée dans [`Utils.TLS.enableTLS`](../client/src/main/java/com/hubsante/Utils.java)
- [x] Evolution des [`Consumer.java`](../client/src/main/java/com/hubsante/Consumer.java) et [`Producer.java`](../client/src/main/java/com/hubsante/Producer.java) pour se connecter en TLS
- [x] Prise en charge par Spring de la connexion TLS du hub via [`application.properties`](../hub/src/main/resources/application.properties)
- [x] Déclaration des files et exchanges RabbitMQ prise en charge par Spring via [`AmqpConfiguration`](../hub/src/main/java/com/hubsante/hub/config/AmqpConfiguration.java)
- [x] Le dossier [`models/`](../models) exploite le fichier de spécifications AsyncAPI pour générer les classes correspondantes
- [x] Les classes sont ensuite intégrés dans [`com.hubsante.message`](../hub/src/main/java/com/hubsante/message) et peuvent être utilisées facilement par les autres fichiers

## Test
```
# Shell 1: run Hub Santé locally
cd hub
docker compose up

# Shell 2: run *.in.message Target-Sante Consumer
cd ../client
CLIENT_ID=Target-Sante; gradle -Pmain=com.hubsante.ConsumerRun run --args "$CLIENT_ID.in.message"

# Shell 3: run *.in.ack Self-Sante Consumer
CLIENT_ID=Self-Sante; gradle -Pmain=com.hubsante.ConsumerRun run --args "$CLIENT_ID.in.ack"

# Shell 4: run Self-Sante Producer each time you want to send a message
CLIENT_ID=Self-Sante; gradle -Pmain=com.hubsante.ProducerRun run --args "$CLIENT_ID.out.message src/main/resources/simpleMessage.json"
```
Test : confirm messages are
- read by message Target-Sante Consumer
- sends Ack back to Hub
- read by Self-Sante ack Consumer
- all correctly technically ack-ed (check through [RabbitMQ UI](http://localhost:15672))

## Scripts utiles
### Docker (RabbitMQ & Hub)
```bash
## Reconstruire les images du Hub (se positionner dans le répertoire /hub)
gradle jibDockerBuild --image=hub-sante:hub

## Lancer le Hub
docker compose up

## Reconstruire et lancer le Hub
gradle jibDockerBuild --image=hub-sante:hub && docker compose up

## SSH dans le noeud RabbitMQ
docker compose exec rabbitmq sh 
```
L'interface [admin de RabbitMQ](http://localhost:15672) est accessible avec le compte guest:guest.

### Consumer / Producer
##### Linux / MAC OS
```bash
## Depuis le répertoire ./client :

## Lancer un Consumer sur $CLIENT_ID.in.message
CLIENT_ID=Target; gradle -Pmain=com.hubsante.ConsumerRun run --args "$CLIENT_ID.in.message"

## Lancer un Consumer sur $CLIENT_ID.in.ack
CLIENT_ID=Origin; gradle -Pmain=com.hubsante.ConsumerRun run --args "$CLIENT_ID.in.ack"

## Envoyer un message sur $CLIENT_ID.out.message avec un Producer
CLIENT_ID=Origin; gradle -Pmain=com.hubsante.ProducerRun run --args "$CLIENT_ID.out.message src/main/resources/createEventMessage.json"
```

##### Windows
```bash
## Depuis le répertoire ./client

## Lancer un Consumer sur $CLIENT_ID.in.message
set CLIENT_ID=Target
gradle -Pmain=com.hubsante.Consumer run --args "%CLIENT_ID%.in.message"

## Lancer un Consumer sur $CLIENT_ID.in.ack
set CLIENT_ID=Origin
gradle -Pmain=com.hubsante.Consumer run --args "%CLIENT_ID%.in.ack"

## Envoyer un message sur $CLIENT_ID.out.message avec un Producer
set CLIENT_ID=Origin
gradle -Pmain=com.hubsante.ProducerRun run --args "$CLIENT_ID.out.message src/main/resources/createEventMessage.json"
```

### Certificats
```bash
## Générer votre CSR (en remplaçant la valeur client de $DOMAIN par votre identifiant client) 
cd certs
DOMAIN=client ./generate.sh
## Après transmission de votre CSR à l'équipe Hub Santé, vous recevrez un certificat signé par l'AC (en .crt)

## Conversion en .p12
export DOMAIN=client; openssl pkcs12 -inkey "$DOMAIN".key -in "$DOMAIN".crt -export -out "$DOMAIN".p12

## Ajouter le Hub au trustStore utilisé par le client
keytool -import -alias RabbitMQHubSante -file rabbitmq/certs/hub.crt -keystore certs/trustStore

## Voir les détails d'un certificat
export DOMAIN=client; openssl x509 -text -noout -in "$DOMAIN".crt

## Vérifier qu'un certificat est bien signé par la CA
openssl verify -CAfile certs/CA/rootCA.crt certs/client.crt
```

### TLS
Ref.: https://www.rabbitmq.com/troubleshooting-ssl.html
```bash
## Créer un serveur TLS avec les certificats du Hub
openssl s_server -accept 8443 -cert rabbitmq/certs/hub.crt -key rabbitmq/certs/hub.key -CAfile rabbitmq/certs/rootCA.crt

## Créer un client se connectant en TLS avec les certificats clients au serveur TLS
openssl s_client -connect localhost:8443 \
  -cert certs/client.crt -key certs/client.key -CAfile certs/CA/rootCA.crt \
  -verify 8

## Créer un client se connectant en TLS avec les certificats clients au RabbitMQ
### Va donner un `handshake_timeout`dans les logs RabbitMQ car aucune donnée n'est transmise
### Mais une ligne similaire devrait apparaitre : [info] <0.769.0> accepting AMQP connection <0.769.0>
openssl s_client -connect localhost:5671 -cert certs/client.crt -key certs/client.key -CAfile certs/CA/rootCA.crt

## Créer un client se connectant en TLS1.1 avec les certificats clients au RabbitMQ -> retourne une `alert protocol version`
openssl s_client -connect localhost:5671 -cert certs/client.crt -key certs/client.key -CAfile certs/CA/rootCA.crt -tls1.1 

## Après SSH dans le noeud RabbitMQ (voir section Scripts utiles > Docker), voir les `listeners` actifs
rabbitmq-diagnostics status # Section Listeners doit avoir une ligne sur le port 5671
```

### Génération des classes basées sur les spécifications AsyncAPI
Plus de détails sont disponibles directement dans [`models/`](../models/README.md)
```bash
## Générer les classes
cd models; npm run generate

## Afficher localement la documentation sur http://localhost:8000
cd docs/specs; python -m http.server 
```
